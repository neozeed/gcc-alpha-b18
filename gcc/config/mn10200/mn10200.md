;; CYGNUS LOCAL entire file/law
;; GCC machine description for Matsushita MN10200
;; Copyright (C) 1997 Free Software Foundation, Inc.

;; Contributed by Jeff Law (law@cygnus.com).

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; The original PO technology requires these to be ordered by speed,
;; so that assigner will pick the fastest.

;; See file "rtl.def" for documentation on define_insn, match_*, et. al.

;; To compare a memory and branch based on ZF/NF we can use a sequence
;; like mov[bu] mem, dreg; add dreg,dreg; bCC wherever.  Note that ZF
;; would be in CF.  Simlarly for testing a dreg against zero if dreg
;; dies.
;;
;; We tried the memory variant, but, in general, it created worse code.

;; Condition code settings.
;; none - insn does not affect cc
;; none_0hit - insn does not affect cc but it does modify operand 0
;;	This attribute is used to keep track of when operand 0 changes.
;; 	See the description of NOTICE_UPDATE_CC for more info.
;; tst - this is a tst insn, sets z,n,v c is set to 0
;;      (c may not really be set to 0 but that's ok, we don't need it anyway).
;; set_zn_c0 - insn sets z,n to usable values.  v is unknown.  c may or may not
;;	be known (if it isn't that's ok, we don't need it anyway).
;; compare - compare instruction
;; clobber - value of cc is unknown
(define_attr "cc" "none,none_0hit,tst,set_zn_c0,compare,clobber"
  (const_string "clobber"))

;; ----------------------------------------------------------------------
;; MOVE INSTRUCTIONS
;; ----------------------------------------------------------------------
;;
;; Some general notes on move instructions.
;;
;; The hardware can't encode nop moves involving data registers, so
;; we catch them and emit a nop instead.
;;
;; Loads/stores to/from address registers must be 16bit aligned,
;; thus we avoid them for QImode.
;;
;; Stores from address registers always store 24bits, so avoid
;; stores from address registers in HImode, SImode, and SFmode.
;;
;; As a result of the various problems using address registers in
;; QImode, HImode, SImode, and SFmode, we discourage their use via
;; '*' in their constraints.  They're still allowed, but they're never
;; the preferred class for for insns with those modes.

;; movqi

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand0, QImode)
      && !register_operand (operand1, QImode))
    operands[1] = copy_to_mode_reg (QImode, operand1);
}")

;; We avoid memory operations involving address registers because we
;; can't be sure they'll be suitably aligned.
;;
;; We also discourage holding QImode values in address registers.
(define_insn ""
  [(set (match_operand:QI 0 "general_operand" "=d,d,*a,d,d,m,d,*a,*a")
	(match_operand:QI 1 "general_operand" "0,I,I,di,m,d,*a,d,i*a"))]
  "register_operand (operands[0], QImode)
   || register_operand (operands[1], QImode)"
  "@
  nop
  sub %0,%0
  sub %0,%0
  mov %S1,%0
  movbu %1,%0
  movb %1,%0
  mov %1,%0
  mov %1,%0
  mov %1,%0"
  [(set_attr "cc" "none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")])

;; movhi

(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand" "")
	(match_operand:HI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand1, HImode)
      && !register_operand (operand0, HImode))
    operands[1] = copy_to_mode_reg (HImode, operand1);
}")

(define_insn ""
  [(set (match_operand:HI 0 "general_operand" "=d,d,*a,d,d,m,d,*a,*a,*a")
	(match_operand:HI 1 "general_operand" "0,I,I,di,m,d,*a,d,i*a,m"))]
  "register_operand (operands[0], HImode)
   || register_operand (operands[1], HImode)"
  "@
  nop
  sub %0,%0
  sub %0,%0
  mov %s1,%0
  mov %1,%0
  mov %1,%0
  mov %1,%0
  mov %1,%0
  mov %1,%0
  mov %A1,%0"
  [(set_attr "cc" "none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")])

;; movpsi and helpers

(define_expand "movpsi"
  [(set (match_operand:PSI 0 "general_operand" "")
	(match_operand:PSI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand1, PSImode)
      && !register_operand (operand0, PSImode))
    operands[1] = copy_to_mode_reg (PSImode, operand1);
}")


;; Constant and indexed addresses are not valid addresses for PSImode,
;; therefore they won't be matched by the general movpsi pattern below.
;; ??? We had patterns to handle indexed addresses, but they kept making
;; us run out of regs, so they were eliminated.

(define_insn ""
  [(set (match_operand:PSI 0 "register_operand" "=a")
	(match_operand:PSI 1 "constant_memory_operand" ""))]
  ""
  "mov %A1,%0"
  [(set_attr "cc" "none_0hit")])

(define_insn ""
  [(set (match_operand:PSI 0 "constant_memory_operand" "=X")
	(match_operand:PSI 1 "register_operand" "a"))]
  ""
  "mov %1,%A0"
  [(set_attr "cc" "none_0hit")])

;; We want to prefer address registers here because 24bit moves to/from
;; memory are shorter and faster when done via address registers.
(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,a?d,?da,a,m,?d,m")
	(match_operand:PSI 1 "general_operand" "0,I,?dai,m,a,m,?d"))]
  "register_operand (operands[0], PSImode)
   || register_operand (operands[1], PSImode)"
  "@
  nop
  sub %0,%0
  mov %1,%0
  mov %A1,%0
  mov %1,%A0
  movx %A1,%0
  movx %1,%A0"
  [(set_attr "cc" "none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")])

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand1, SImode)
      && !register_operand (operand0, SImode))
    operands[1] = copy_to_mode_reg (SImode, operand1);
}")

(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=d,d,*a,dm,d,d,*a,*a,*a")
	(match_operand:SI 1 "general_operand" "0,I,I,d,dim,*a,d,*a,i"))]
  "register_operand (operands[0], SImode)
   || register_operand (operands[1], SImode)"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"nop\";
    case 1:
    case 2:
      return \"sub %H0,%H0\;sub %L0,%L0\";
    case 3:
    case 5:
    case 6:
    case 7:
      return \"mov %H1,%H0\;mov %L1,%L0\";

    /* The next two cases try to optimize cases where one half
       of the constant is all zeros, or when the two halves are
       the same.  */
    case 4:
    case 8:
      if (REG_P (operands[0])
	  && GET_CODE (operands[1]) == CONST_INT
	  && (INTVAL (operands[1]) & 0xffff0000) == 0)
	output_asm_insn (\"sub %H0,%H0\", operands);
      else
	output_asm_insn (\"mov %h1,%H0\", operands);

      if (GET_CODE (operands[1]) == CONST_INT
	  && ((INTVAL (operands[1]) & 0xffff)
	      == ((INTVAL (operands[1]) >> 16) & 0xffff)))
	output_asm_insn (\"mov %H0,%L0\", operands);
      else if (GET_CODE (operands[1]) == CONST_INT
	       && (INTVAL (operands[1]) & 0xffff) == 0)
	output_asm_insn (\"sub %L0,%L0\", operands);
      else
	output_asm_insn (\"mov %o1,%L0\", operands);
      return \"\";
    }
}"
  [(set_attr "cc" "none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")])

(define_expand "movsf"
  [(set (match_operand:SF 0 "general_operand" "")
	(match_operand:SF 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand1, SFmode)
      && !register_operand (operand0, SFmode))
    operands[1] = copy_to_mode_reg (SFmode, operand1);
}")

(define_insn ""
  [(set (match_operand:SF 0 "general_operand" "=d,d,*a,dm,d,d,*a,*a,*a")
	(match_operand:SF 1 "general_operand" "0,G,G,d,dim,*a,d,*a,i"))]
  "register_operand (operands[0], SFmode)
   || register_operand (operands[1], SFmode)"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"nop\";

    case 1:
    case 2:
      return \"sub %H0,%H0\;sub %L0,%L0\";

    default:
      {
        long val;
        REAL_VALUE_TYPE rv;

	if (GET_CODE (operands[1]) == CONST_DOUBLE)
	  {
	    REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);
	    REAL_VALUE_TO_TARGET_SINGLE (rv, val);
	  }

	if (GET_CODE (operands[1]) == CONST_INT)
	  val = INTVAL (operands[1]);

        if ((GET_CODE (operands[1]) == CONST_INT
	     || GET_CODE (operands[1]) == CONST_DOUBLE)
	    && (val & 0xffff0000) == 0)
	  output_asm_insn (\"sub %H0,%H0\", operands);
	else
	  output_asm_insn (\"mov %h1,%H0\", operands);
	
	if (GET_CODE (operands[1]) == CONST_INT
	    && ((INTVAL (operands[1]) & 0xffff)
		 == ((INTVAL (operands[1]) >> 16) & 0xffff)))
	  output_asm_insn (\"mov %H0,%L0\", operands);
        else if ((GET_CODE (operands[1]) == CONST_INT
		  || GET_CODE (operands[1]) == CONST_DOUBLE)
		 && (val & 0x0000ffff) == 0)
	  output_asm_insn (\"sub %L0,%L0\", operands);
	else
	  output_asm_insn (\"mov %o1,%L0\", operands);
	return \"\";
      }
    }
}"
  [(set_attr "cc" "none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")])


;; ----------------------------------------------------------------------
;; TEST INSTRUCTIONS
;; ----------------------------------------------------------------------

;; Go ahead and define tsthi and tstpsi so we can eliminate redundant tst insns
;; when we start trying to optimize this port.
(define_insn "tsthi"
  [(set (cc0) (match_operand:HI 0 "general_operand" "da"))]
  ""
  "* return output_tst (operands[0], insn);"
  [(set_attr "cc" "tst")])

(define_insn "tstpsi"
  [(set (cc0) (match_operand:PSI 0 "general_operand" "da"))]
  ""
  "* return output_tst (operands[0], insn);"
  [(set_attr "cc" "tst")])

(define_insn ""
  [(set (cc0) (zero_extend:HI (match_operand:QI 0 "memory_operand" "d")))]
  ""
  "* return output_tst (operands[0], insn);"
  [(set_attr "cc" "tst")])

(define_insn ""
  [(set (cc0) (zero_extend:PSI (match_operand:QI 0 "memory_operand" "d")))]
  ""
  "* return output_tst (operands[0], insn);"
  [(set_attr "cc" "tst")])

(define_insn "cmphi"
  [(set (cc0)
	(compare:HI (match_operand:HI 0 "general_operand" "da")
		    (match_operand:HI 1 "general_operand" "dai")))]
  ""
  "cmp %1,%0"
  [(set_attr "cc" "compare")])

(define_insn "cmppsi"
  [(set (cc0)
	(compare:PSI (match_operand:PSI 0 "general_operand" "da")
		     (match_operand:PSI 1 "general_operand" "dai")))]
  ""
  "cmp %1,%0"
  [(set_attr "cc" "compare")])

;; ----------------------------------------------------------------------
;; ADD INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "addhi3"
  [(set (match_operand:HI 0 "general_operand" "=d")
	(plus:HI (match_operand:HI 1 "general_operand" "%0")
		 (match_operand:HI 2 "general_operand" "dai")))]
  ""
  "add %2,%0"
  [(set_attr "cc" "set_zn_c0")])

(define_insn "addpsi3"
  [(set (match_operand:PSI 0 "general_operand" "=da")
	(plus:PSI (match_operand:PSI 1 "general_operand" "%0")
		  (match_operand:PSI 2 "general_operand" "dai")))]
  ""
  "add %2,%0"
  [(set_attr "cc" "set_zn_c0")])

;; It has been profitable for addsi3 and subsi3 to only operate on
;; explicit hard registers instead of pseudos.  I guess because it
;; makes register allocation easier.
;;
;; Best case if we call out to a magic addsi3/subsi3 function would
;; be 3 bytes/7 cycles if we can relax the call, otherwise it is
;; 5 bytes/9 cycles.
;;
;; The inline variant operating on explicit hard registers is
;; always 3 bytes/3 cycles, obviously the inline variant wins.
;;
;; If operands2 is a constant, then we can do a little better by
;; loading just the high part of the constant into a register,
;; the low part appears as an immediate in the first add/sub insn.
;; This saves 1 byte and reduces register pressure.
;; This optimization isn't needed for subsi3 as subtracting
;; a constant should always be changed into adding the negative
;; of the same constant.
;;
(define_expand "addsi3"
  [(set (reg:SI 0) (match_operand:SI 1 "register_operand" ""))
   (set (reg:SI 2) (match_operand:SI 2 "nonmemory_operand" ""))
   (set (reg:SI 0) (plus:SI (reg:SI 0) (reg:SI 2)))
   (set (match_operand:SI 0 "register_operand" "") (reg:SI 0))]
  ""
  "
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      rtx reg0 = gen_rtx (REG, SImode, 0);

      emit_move_insn (reg0, operands[1]);
      emit_insn (gen_addsi3_const (operands[2]));
      emit_move_insn (operands[0], reg0);
      DONE;
    }
}")

;; The general addsi3 pattern.
(define_insn ""
  [(set (reg:SI 0) (plus:SI (reg:SI 0) (reg:SI 2)))]
  ""
  "add d2,d0\;addc d3,d1"
  [(set_attr "cc" "clobber")])

;; addsi3 with on operand being a constant.
(define_insn "addsi3_const"
  [(set (reg:SI 0)
        (plus:SI (reg:SI 0) (match_operand:SI 0 "const_int_operand" "i")))
   (clobber (reg:SI 2))]
  ""
  "*
{
  unsigned long value = INTVAL (operands[0]);

  /* If only the high bits are set in the constant, then we only
     need a single add operation.  It might be better to catch this
     at RTL expansion time.  */
  if ((value & 0xffff) == 0)
    return \"add %h0,d0\";

  value >>= 16;
  value &= 0xffff;

  if (value == 0)
    return \"sub d2,d2\;add %o0,d0\;addc d2,d1\";
  else
    return \"mov %h0,d2\;add %o0,d0\;addc d2,d1\";
}"
  [(set_attr "cc" "clobber")])

;; ----------------------------------------------------------------------
;; SUBTRACT INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "subhi3"
  [(set (match_operand:HI 0 "general_operand" "=d")
	(minus:HI (match_operand:HI 1 "general_operand" "0")
		  (match_operand:HI 2 "general_operand" "dai")))]
  ""
  "sub %2,%0"
  [(set_attr "cc" "compare")])

(define_insn "subpsi3"
  [(set (match_operand:PSI 0 "general_operand" "=da")
	(minus:PSI (match_operand:PSI 1 "general_operand" "0")
		  (match_operand:PSI 2 "general_operand" "dai")))]
  ""
  "sub %2,%0"
  [(set_attr "cc" "compare")])

(define_expand "subsi3"
  [(set (reg:SI 0) (match_operand:SI 1 "register_operand" ""))
   (set (reg:SI 2) (match_operand:SI 2 "nonmemory_operand" ""))
   (set (reg:SI 0) (minus:SI (reg:SI 0) (reg:SI 2)))
   (set (match_operand:SI 0 "register_operand" "") (reg:SI 0))]
  ""
  "")

(define_insn ""
  [(set (reg:SI 0) (minus:SI (reg:SI 0) (reg:SI 2)))]
  ""
  "sub d2,d0\;subc d3,d1"
  [(set_attr "cc" "clobber")])

;; There isn't a negate instruction, so we fake it.
;;
;; We used to expand this into patterns, but a single pattern
;; actually generates better overall code.
;; 
;; We could do HImode negations with a "not;add" sequence, but
;; generally it's generated slightly worse code.
(define_insn "neghi2"
  [(set (match_operand:HI 0 "general_operand" "=&d")
        (neg:HI (match_operand:HI 1 "general_operand" "d")))]
  ""
  "sub %0,%0\;sub %1,%0"
  [(set_attr "cc" "set_zn_c0")])

(define_insn "negpsi2"
  [(set (match_operand:PSI 0 "general_operand" "=&d")
        (neg:PSI (match_operand:PSI 1 "general_operand" "d")))]
  ""
  "sub %0,%0\;sub %1,%0"
  [(set_attr "cc" "set_zn_c0")])

;; Using a magic libcall that accepts its arguments in any
;; data register pair has proven to be the most efficient
;; and most compact way to represent negsi2.
(define_insn "negsi2"
  [(set (match_operand:SI 0 "general_operand" "=d")
	(neg:SI (match_operand:SI 1 "general_operand" "0")))]
  ""
  "jsr ___negsi2_%0"
  [(set_attr "cc" "clobber")])
 
;; ----------------------------------------------------------------------
;; MULTIPLY INSTRUCTIONS
;; ----------------------------------------------------------------------
;;
;; The mn10200 has HIxHI->SI widening multiply, but we get _severe_
;; code density regressions if we enable such a pattern.

(define_insn "mulhi3"
  [(set (match_operand:HI 0 "general_operand" "=d")
	(mult:HI (match_operand:HI 1 "general_operand" "%0")
		 (match_operand:HI 2 "general_operand" "d")))]
  ""
  "mul %2,%0"
  [(set_attr "cc" "set_zn_c0")])

(define_expand "udivmodhi4"
  [(parallel [(set (match_operand:HI 0 "general_operand" "")
		   (udiv:HI (match_operand:HI 1 "general_operand" "")
			    (match_operand:HI 2 "general_operand" "")))
	      (set (match_operand:HI 3 "general_operand" "")
		   (umod:HI (match_dup 1) (match_dup 2)))])]
  ""
  "
{
  rtx reg = gen_reg_rtx (HImode);
  emit_move_insn (reg, GEN_INT (0));
  emit_insn (gen_clear_mdr (reg));
}")

(define_insn ""
  [(set (match_operand:HI 0 "general_operand" "=d")
	(udiv:HI (match_operand:HI 1 "general_operand" "0")
		 (match_operand:HI 2 "general_operand" "d")))
   (set (match_operand:HI 3 "general_operand" "=d")
	(umod:HI (match_dup 1) (match_dup 2)))]
  ""
  "*
{
  if (find_reg_note (insn, REG_UNUSED, operands[3]))
    return \"divu %2,%0\";
  else
    return \"divu %2,%0\;mov mdr,%3\";
}"
  [(set_attr "cc" "set_zn_c0")])

(define_insn "clear_mdr"
  [(unspec_volatile [(const_int 2)] 0)
   (use (match_operand:HI 0 "general_operand" "d"))]
  ""
  "mov %0,mdr"
  [(set_attr "cc" "none")])


;; ----------------------------------------------------------------------
;; AND INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "andhi3"
  [(set (match_operand:HI 0 "general_operand" "=d,d")
	(and:HI (match_operand:HI 1 "general_operand" "%0,0")
		(match_operand:HI 2 "general_operand" "M,di")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xff)
    return \"extxbu %0\";
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x7fff)
    return \"add %0,%0\;lsr %0\";
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffe)
    return \"lsr %0\;add %0,%0\";
  return \"and %2,%0\";
}"
  [(set_attr "cc" "none_0hit,set_zn_c0")])

;; This expander + pattern exist only to allow trampolines to be aligned
;; in the stack.
(define_expand "andpsi3"
  [(set (match_operand:PSI 0 "general_operand" "")
	(and:PSI (match_operand:PSI 1 "general_operand" "")
		(match_operand:PSI 2 "const_int_operand" "")))]
  ""
  "
{
  if (GET_CODE (operands[2]) != CONST_INT
      || (INTVAL (operands[2]) & 0xff0000) != 0xff0000)
    FAIL;
}")

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d")
	(and:PSI (match_operand:PSI 1 "general_operand" "%0")
		(match_operand:PSI 2 "const_int_operand" "i")))]
  "GET_CODE (operands[2]) == CONST_INT
   && (INTVAL (operands[2]) & 0xff0000) == 0xff0000"
  "and %2,%0"
  [(set_attr "cc" "clobber")])

;; ----------------------------------------------------------------------
;; OR INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "iorhi3"
  [(set (match_operand:HI 0 "general_operand" "=d")
	(ior:HI (match_operand:HI 1 "general_operand" "%0")
		(match_operand:HI 2 "general_operand" "di")))]
  ""
  "or %2,%0"
  [(set_attr "cc" "set_zn_c0")])

;; ----------------------------------------------------------------------
;; XOR INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "xorhi3"
  [(set (match_operand:HI 0 "general_operand" "=d")
	(xor:HI (match_operand:HI 1 "general_operand" "%0")
		(match_operand:HI 2 "general_operand" "di")))]
  ""
  "xor %2,%0"
  [(set_attr "cc" "set_zn_c0")])

;; ----------------------------------------------------------------------
;; NOT INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "general_operand" "=d")
	(not:HI (match_operand:HI 1 "general_operand" "0")))]
  ""
  "not %0"
  [(set_attr "cc" "set_zn_c0")])


;; -----------------------------------------------------------------
;; BIT INSTRUCTIONS
;; -----------------------------------------------------------------

;; When clearing a set of bits in memory, we load the inverted bitmask into
;; a register, then use bclr.
(define_insn ""
  [(set (match_operand:QI 0 "indirect_memory_operand" "")
	(subreg:QI
	  (and:HI (subreg:HI (match_dup 0) 0)
		  (match_operand 1 "const_int_operand" "")) 0))
   (clobber (match_scratch:HI 2 "=&d"))]
  ""
  "mov %N1,%2\;bclr %2,%0"
  [(set_attr "cc" "clobber")])

;; These clear a non-constant set of bits in memory.
(define_insn ""
  [(set (match_operand:QI 0 "indirect_memory_operand" "")
	(subreg:QI
	  (and:HI (subreg:HI (match_dup 0) 0)
		  (not:HI (match_operand:HI 1 "general_operand" "d"))) 0))]
  ""
  "bclr %1,%0"
  [(set_attr "cc" "clobber")])

(define_insn ""
  [(set (match_operand:QI 0 "indirect_memory_operand" "")
	(subreg:QI
	  (and:HI (not:HI (match_operand:HI 1 "general_operand" "d"))
		  (subreg:HI (match_dup 0) 0)) 0))]
  ""
  "bclr %1,%0"
  [(set_attr "cc" "clobber")])

;; These set bits in memory.
(define_insn ""
  [(set (match_operand:QI 0 "indirect_memory_operand" "")
	(subreg:QI
	  (ior:HI (subreg:HI (match_dup 0) 0)
		  (match_operand:HI 1 "general_operand" "d")) 0))]
  ""
  "bset %1,%0"
  [(set_attr "cc" "clobber")])

(define_insn ""
  [(set (match_operand:QI 0 "indirect_memory_operand" "")
	(subreg:QI
	  (ior:HI (match_operand:HI 1 "general_operand" "d")
		  (subreg:HI (match_dup 0) 0)) 0))]
  ""
  "bset %1,%0"
  [(set_attr "cc" "clobber")])

;; Not any shorter/faster than using cmp, but it might save a
;; register if the result of the AND isn't ever used.

(define_insn ""
  [(set (cc0)
     (zero_extract:HI (match_operand:HI 0 "general_operand" "d")
		      (match_operand 1 "const_int_operand" "")
		      (match_operand 2 "const_int_operand" "")))]
  ""
  "*
{
  int len = INTVAL (operands[1]);
  int bit = INTVAL (operands[2]);
  int mask = 0;
  rtx xoperands[2];

  while (len > 0)
    {
      mask |= (1 << bit);
      bit++;
      len--;
    }

  xoperands[0] = operands[0];
  xoperands[1] = GEN_INT (mask);
  output_asm_insn (\"btst %1,%0\", xoperands);
  return \"\";
}"
  [(set_attr "cc" "set_zn_c0")])

(define_insn ""
  [(set (cc0) (and:HI (match_operand:HI 0 "general_operand" "d")
		      (match_operand:HI 1 "const_int_operand" "i")))]
  ""
  "btst %1,%0"
  [(set_attr "cc" "set_zn_c0")])

;; -----------------------------------------------------------------
;; Scc INSTRUCTIONS
;; -----------------------------------------------------------------
;; It's probably worth the time to define setcc type insns for the
;; mn10200.  The question is which ones can we define?

;; ?!? Is this really safe?
;; The way I see it, we lose if the compiler decides that
;; the compare this insn depends on can be turned into
;; a tst insn.
;;
;; A working sgtu would be a big help for 32bit subtraction,
;; but it runs into the compare->tst problem mentioned above.
(define_insn "sltu"
  [(set (match_operand:HI 0 "general_operand" "=d")
	(ltu:HI (cc0) (const_int 0)))]
  ""
  "mov 0,%0\;addc %0,%0"
  [(set_attr "cc" "clobber")])

;; Unconditional and other jump instructions.


;; ----------------------------------------------------------------------
;; JUMP INSTRUCTIONS
;; ----------------------------------------------------------------------

;; Conditional jump instructions

(define_expand "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_insn ""
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
      && (GET_CODE (operands[1]) == GT
          || GET_CODE (operands[1]) == GE
          || GET_CODE (operands[1]) == LE
          || GET_CODE (operands[1]) == LT))
    return 0;

  if (GET_MODE (SET_SRC (PATTERN (PREV_INSN (insn)))) == PSImode)
    return \"b%b1x %0\";
  else
    return \"b%b1 %0\";
}"
 [(set_attr "cc" "none")])

(define_insn ""
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
      && (GET_CODE (operands[1]) == GT
          || GET_CODE (operands[1]) == GE
          || GET_CODE (operands[1]) == LE
          || GET_CODE (operands[1]) == LT))
    return 0;

  if (GET_MODE (SET_SRC (PATTERN (PREV_INSN (insn)))) == PSImode)
    return \"b%B1x %0\";
  else
    return \"b%B1 %0\";
}"
 [(set_attr "cc" "none")])

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp %l0"
 [(set_attr "cc" "none")])

(define_insn "indirect_jump"
  [(set (pc) (match_operand:PSI 0 "general_operand" "a"))]
  ""
  "jmp (%0)"
  [(set_attr "cc" "none")])

(define_insn "tablejump"
  [(set (pc) (match_operand:PSI 0 "general_operand" "a"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  "jmp  (%0)"
  [(set_attr "cc" "none")])

;; Call subroutine with no return value.

(define_expand "call"
  [(call (match_operand:QI 0 "general_operand" "")
	 (match_operand:HI 1 "general_operand" ""))]
  ""
  "
{
  if (! call_address_operand (XEXP (operands[0], 0)))
    XEXP (operands[0], 0) = force_reg (PSImode, XEXP (operands[0], 0));
  emit_call_insn (gen_call_internal (XEXP (operands[0], 0), operands[1]));
  DONE;
}")

(define_insn "call_internal"
  [(call (mem:QI (match_operand:PSI 0 "call_address_operand" "aS"))
	 (match_operand:HI 1 "general_operand" "g"))]
  ""
  "jsr %C0"
  [(set_attr "cc" "clobber")])

;; Call subroutine, returning value in operand 0
;; (which must be a hard register).

(define_expand "call_value"
  [(set (match_operand 0 "" "")
	(call (match_operand:QI 1 "general_operand" "")
	      (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  if (! call_address_operand (XEXP (operands[1], 0)))
    XEXP (operands[1], 0) = force_reg (PSImode, XEXP (operands[1], 0));
  emit_call_insn (gen_call_value_internal (operands[0],
					   XEXP (operands[1], 0),
					   operands[2]));
  DONE;
}")

(define_insn "call_value_internal"
  [(set (match_operand 0 "" "=d")
	(call (mem:QI (match_operand:PSI 1 "call_address_operand" "aS"))
	      (match_operand:HI 2 "general_operand" "g")))]
  ""
  "jsr %C1"
  [(set_attr "cc" "clobber")])

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "cc" "none")])

;; ----------------------------------------------------------------------
;; EXTEND INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "general_operand" "=d,d,d")
	(zero_extend:HI
	 (match_operand:QI 1 "general_operand" "0,d,m")))]
  ""
  "@
  extxbu %0
  mov %1,%0\;extxbu %0
  movbu %1,%0"
  [(set_attr "cc" "none_0hit")])

(define_insn "zero_extendqipsi2"
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(zero_extend:PSI
	 (match_operand:QI 1 "general_operand" "0,d,m")))]
  ""
  "@
  extxbu %0
  mov %1,%0\;extxbu %0
  movbu %1,%0"
  [(set_attr "cc" "none_0hit")])

(define_insn "zero_extendqisi2"
  [(set (match_operand:SI 0 "general_operand" "=d,d,d")
	(zero_extend:SI
	 (match_operand:QI 1 "general_operand" "0,d,m")))]
  ""
  "@
  extxbu %L0\;sub %H0,%H0
  mov %1,%L0\;extxbu %L0\;sub %H0,%H0
  movbu %1,%L0\;sub %H0,%H0"
  [(set_attr "cc" "none_0hit")])

(define_insn "zero_extendhipsi2"
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(zero_extend:PSI
	 (match_operand:HI 1 "general_operand" "0,d,m")))]
  ""
  "@
  extxu %0
  mov %1,%0\;extxu %0
  mov %1,%0\;extxu %0"
  [(set_attr "cc" "none_0hit")])

(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=d,d")
	(zero_extend:SI
	 (match_operand:HI 1 "general_operand" "0,dm")))]
  ""
  "@
  sub %H0,%H0
  mov %1,%L0\;sub %H0,%H0"
  [(set_attr "cc" "none_0hit")])

(define_insn "zero_extendpsisi2"
  [(set (match_operand:SI 0 "register_operand" "=d,?d,?*d")
	(zero_extend:SI (match_operand:PSI 1 "general_operand" "m,?0,?*da")))]
  ""
  "@
  mov %L1,%L0\;movbu %H1,%H0
  jsr ___zero_extendpsisi2_%0
  mov %1,%L0\;jsr ___zero_extendpsisi2_%0"
  [(set_attr "cc" "clobber")])

;;- sign extension instructions

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "general_operand" "=d,d,d")
	(sign_extend:HI
	 (match_operand:QI 1 "general_operand" "0,d,m")))]
  ""
  "*
{
  if (which_alternative == 0)
    return \"extxb %0\";
  else if (which_alternative == 1)
    return \"mov %1,%0\;extxb %0\";
  else if (GET_CODE (XEXP (operands[1], 0)) == REG)
    return \"movbu %1,%0\;extxb %0\";
  else
    return \"movb %1,%0\";
}"
  [(set_attr "cc" "none_0hit")])

(define_insn "extendqipsi2"
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(sign_extend:PSI
	 (match_operand:QI 1 "general_operand" "0,d,m")))]
  ""
  "*
{
  if (which_alternative == 0)
    return \"extxb %0\";
  else if (which_alternative == 1)
    return \"mov %1,%0\;extxb %0\";
  else if (GET_CODE (XEXP (operands[1], 0)) == REG)
    return \"movbu %1,%0\;extxb %0\";
  else
    return \"movb %1,%0\";
}"
  [(set_attr "cc" "none_0hit")])

(define_insn "extendqisi2"
  [(set (match_operand:SI 0 "general_operand" "=d,d,d")
	(sign_extend:SI
	 (match_operand:QI 1 "general_operand" "0,d,m")))]
  ""
  "*
{
  if (which_alternative == 0)
    return \"extxb %L0\;mov %L0,%H0\;add %H0,%H0\;subc %H0,%H0\";
  else if (which_alternative == 1)
    return \"mov %1,%L0\;extxb %L0\;mov %L0,%H0\;add %H0,%H0\;subc %H0,%H0\";
  else if (GET_CODE (XEXP (operands[1], 0)) == REG)
    return \"movbu %1,%L0\;extxb %L0\;mov %L0,%H0\;add %H0,%H0\;subc %H0,%H0\";
  else
    return \"movb %1,%L0\;mov %L0,%H0\;add %H0,%H0\;subc %H0,%H0\";
}"
  [(set_attr "cc" "none_0hit")])

(define_insn "extendhipsi2"
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(sign_extend:PSI
	 (match_operand:HI 1 "general_operand" "0,d,m")))]
  ""
  "@
  extx %0
  mov %1,%0\;extx %0
  mov %1,%0"
  [(set_attr "cc" "none_0hit")])

(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=d,d,d")
	(sign_extend:SI
	 (match_operand:HI 1 "general_operand" "0,d,m")))]
  ""
  "@
  mov %L0,%H0\;add %H0,%H0\;subc %H0,%H0
  mov %1,%L0\;mov %L0,%H0\;add %H0,%H0\;subc %H0,%H0
  mov %1,%L0\;mov %L0,%H0\;add %H0,%H0\;subc %H0,%H0"
  [(set_attr "cc" "none_0hit")])

(define_insn "extendpsisi2"
  [(set (match_operand:SI 0 "general_operand" "=d,?d,?*d")
	(sign_extend:SI (match_operand:PSI 1 "general_operand" "m,?0,?*da")))]
  ""
  "@
  mov %L1,%L0\;movb %H1,%H0
  jsr ___zero_extendpsisi2_%0
  mov %1,%L0\;jsr ___zero_extendpsisi2_%0"
  [(set_attr "cc" "clobber")])

(define_insn "truncsipsi2"
  [(set (match_operand:PSI 0 "general_operand" "=a,?d,?*d")
	(truncate:PSI (match_operand:SI 1 "general_operand" "m,?m,?*d")))]
   ""
   "@
   mov %1,%0
   movx %A1,%0
   jsr ___truncsipsi2_%1_%0"
  [(set_attr "cc" "clobber")])


;; Combine should be simplifying this stuff, but isn't.
;;
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=d,d,d")
	(sign_extend:SI
	  (zero_extend:HI (match_operand:QI 1 "general_operand" "0,d,m"))))]
  ""
  "@
  extxbu %L0\;sub %H0,%H0
  mov %1,%L0\;extxbu %L0\;sub %H0,%H0
  movbu %1,%L0\;sub %H0,%H0"
  [(set_attr "cc" "none_0hit")])

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
        (truncate:PSI
	  (sign_extend:SI (match_operand:QI 1 "general_operand" "0,d,m"))))]
  ""
  "*
{
  if (which_alternative == 0)
    return \"extxb %0\";
  else if (which_alternative == 1)
    return \"mov %1,%0\;extxb %0\";
  else if (GET_CODE (XEXP (operands[1], 0)) == REG)
    return \"movbu %1,%0\;extxb %0\";
  else
    return \"movb %1,%0\";
}"
  [(set_attr "cc" "none_0hit")])

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(truncate:PSI
	  (sign_extend:SI (match_operand:HI 1 "general_operand" "0,d,m"))))]
  ""
  "@
  extx %0
  mov %1,%0\;extx %0
  mov %1,%0"
  [(set_attr "cc" "none_0hit")])

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(truncate:PSI
	  (sign_extend:SI
	    (zero_extend:HI (match_operand:QI 1 "general_operand" "0,d,m")))))]
  ""
  "@
  extxbu %0
  mov %1,%0\;extxbu %0
  movbu %1,%0"
  [(set_attr "cc" "none_0hit")])

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(truncate:PSI
	  (zero_extend:SI (match_operand:HI 1 "general_operand" "0,d,m"))))]
  ""
  "@
  extxu %0
  mov %1,%0\;extxu %0
  mov %1,%0\;extxu %0"
  [(set_attr "cc" "none_0hit")])

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
        (truncate:PSI
	  (zero_extend:SI (match_operand:QI 1 "general_operand" "0,d,m"))))]
  ""
  "@
  extxbu %0
  mov %1,%0\;extxbu %0
  movbu %1,%0"
  [(set_attr "cc" "none_0hit")])

;; ----------------------------------------------------------------------
;; SHIFTS
;; ----------------------------------------------------------------------

;; If the shift count is small, we expand it into several single bit
;; shift insns.  Otherwise we expand into a generic shift insn which
;; handles larger shift counts, shift by variable amounts, etc.
(define_expand "ashlhi3"
  [(set (match_operand:HI 0 "general_operand" "")
	(ashift:HI (match_operand:HI 1 "general_operand" "")
		   (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  /* This is an experiment to see if exposing more of the underlying
     operations results in better code.  */
  if (GET_CODE (operands[2]) == CONST_INT
      && INTVAL (operands[2]) <= 4)
    {
      int count = INTVAL (operands[2]);
      emit_move_insn (operands[0], operands[1]);
      while (count > 0)
	{
	  emit_insn (gen_rtx (SET, HImode, operands[0],
			      gen_rtx (ASHIFT, HImode,
				       operands[0], GEN_INT (1))));
	  count--;
	}
      DONE;
    }
  else
    {
      expand_a_shift (HImode, ASHIFT, operands);
      DONE;
    }
}")

;; ASHIFT one bit.
(define_insn ""
  [(set (match_operand:HI 0 "general_operand" "=d")
	(ashift:HI (match_operand:HI 1 "general_operand" "0")
		   (const_int 1)))]
  ""
  "add %0,%0"
  [(set_attr "cc" "set_zn_c0")])

(define_expand "lshrhi3"
  [(set (match_operand:HI 0 "general_operand" "")
	(lshiftrt:HI (match_operand:HI 1 "general_operand" "")
		     (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  /* This is an experiment to see if exposing more of the underlying
     operations results in better code.  */
  if (GET_CODE (operands[2]) == CONST_INT
      && INTVAL (operands[2]) <= 4)
    {
      int count = INTVAL (operands[2]);
      emit_move_insn (operands[0], operands[1]);
      while (count > 0)
	{
	  emit_insn (gen_rtx (SET, HImode, operands[0],
			      gen_rtx (LSHIFTRT, HImode,
				       operands[0], GEN_INT (1))));
	  count--;
	}
      DONE;
    }
  else
    {
      expand_a_shift (HImode, LSHIFTRT, operands);
      DONE;
    }
}")

;; LSHIFTRT one bit.
(define_insn ""
  [(set (match_operand:HI 0 "general_operand" "=d")
	(lshiftrt:HI (match_operand:HI 1 "general_operand" "0")
		     (const_int 1)))]
  ""
  "lsr %0"
  [(set_attr "cc" "set_zn_c0")])

(define_expand "ashrhi3"
  [(set (match_operand:HI 0 "general_operand" "")
	(ashiftrt:HI (match_operand:HI 1 "general_operand" "")
		     (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  /* This is an experiment to see if exposing more of the underlying
     operations results in better code.  */
  if (GET_CODE (operands[2]) == CONST_INT
      && INTVAL (operands[2]) <= 4)
    {
      int count = INTVAL (operands[2]);
      emit_move_insn (operands[0], operands[1]);
      while (count > 0)
	{
	  emit_insn (gen_rtx (SET, HImode, operands[0],
			      gen_rtx (ASHIFTRT, HImode,
				       operands[0], GEN_INT (1))));
	  count--;
	}
      DONE;
    }
  else
    {
      expand_a_shift (HImode, ASHIFTRT, operands);
      DONE;
    }
}")

;; ASHIFTRT one bit.
(define_insn ""
  [(set (match_operand:HI 0 "general_operand" "=d")
	(ashiftrt:HI (match_operand:HI 1 "general_operand" "0")
		     (const_int 1)))]
  ""
  "asr %0"
  [(set_attr "cc" "set_zn_c0")])

;; And the general HImode shift pattern.  Handles both shift by constants
;; and shift by variable counts.
(define_insn ""
  [(set (match_operand:HI 0 "general_operand" "=d,d")
	(match_operator:HI 3 "nshift_operator" 
			[ (match_operand:HI 1 "general_operand" "0,0")
			  (match_operand:HI 2 "general_operand" "KL,dan")]))
   (clobber (match_scratch:HI 4 "=X,&d"))]
  ""
  "* return emit_a_shift (insn, operands);"
  [(set_attr "cc" "clobber")])

;; We expect only ASHIFT with constant shift counts to be common for
;; PSImode, so we optimize just that case.  For all other cases we
;; extend the value to SImode and perform the shift in SImode.
(define_expand "ashlpsi3"
  [(set (match_operand:PSI 0 "general_operand" "")
	(ashift:PSI (match_operand:PSI 1 "general_operand" "")
		   (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  /* This is an experiment to see if exposing more of the underlying
     operations results in better code.  */
  if (GET_CODE (operands[2]) == CONST_INT
      && INTVAL (operands[2]) <= 7)
    {
      int count = INTVAL (operands[2]);
      emit_move_insn (operands[0], operands[1]);
      while (count > 0)
	{
	  emit_insn (gen_rtx (SET, PSImode, operands[0],
			      gen_rtx (ASHIFT, PSImode,
				       operands[0], GEN_INT (1))));
	  count--;
	}
      DONE;
    }
  else
    {
      expand_a_shift (PSImode, ASHIFT, operands);
      DONE;
    }
}")

;; ASHIFT one bit.
(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d")
	(ashift:PSI (match_operand:PSI 1 "general_operand" "0")
		    (const_int 1)))]
  ""
  "add %0,%0"
  [(set_attr "cc" "set_zn_c0")])

(define_expand "lshrpsi3"
  [(set (match_operand:PSI 0 "general_operand" "")
	(lshiftrt:PSI (match_operand:PSI 1 "general_operand" "")
		     (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  rtx reg = gen_reg_rtx (SImode);

  emit_insn (gen_zero_extendpsisi2 (reg, operands[1]));
  reg = expand_binop (SImode, lshr_optab, reg,
		      operands[2], reg, 1, OPTAB_WIDEN);
  emit_insn (gen_truncsipsi2 (operands[0], reg));
  DONE;
}")

(define_expand "ashrpsi3"
  [(set (match_operand:PSI 0 "general_operand" "")
	(ashiftrt:PSI (match_operand:PSI 1 "general_operand" "")
		     (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  rtx reg = gen_reg_rtx (SImode);

  emit_insn (gen_extendpsisi2 (reg, operands[1]));
  reg = expand_binop (SImode, ashr_optab, reg,
		      operands[2], reg, 0, OPTAB_WIDEN);
  emit_insn (gen_truncsipsi2 (operands[0], reg));
  DONE;
}")

(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(ashift:SI (match_operand:SI 1 "nonmemory_operand" "")
		   (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  /* The machine independent code can optimize shifts of 16bits or
     greater reasonably well, so we don't bother with them, nor do we
     bother with shifts by a variable count -- we leave that to 
     library code.  */
  if (GET_CODE (operands[2]) == CONST_INT
      && (INTVAL (operands[2]) <= 15))
    {
      expand_a_shift (SImode, ASHIFT, operands);
      DONE;
    }
  else
    FAIL;
}")

(define_expand "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(lshiftrt:SI (match_operand:SI 1 "general_operand" "")
		     (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  /* The machine independent code can optimize shifts of 16bits or
     greater reasonably well, so we don't bother with them, nor do we
     bother with shifts by a variable count -- we leave that to 
     library code.  */
  if (GET_CODE (operands[2]) == CONST_INT
      && (INTVAL (operands[2]) <= 15))
    {
      expand_a_shift (SImode, LSHIFTRT, operands);
      DONE;
    }
  else
    FAIL;
}")

(define_expand "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(ashiftrt:SI (match_operand:SI 1 "register_operand" "")
		     (match_operand:HI 2 "general_operand" "")))]
  ""
  "
{
  /* The machine independent code can optimize shifts of 16bits or
     greater reasonably well, so we don't bother with them, nor do we
     bother with shifts by a variable count -- we leave that to 
     library code.  */
  if (GET_CODE (operands[2]) == CONST_INT
      && (INTVAL (operands[2]) <= 15))
    {
      expand_a_shift (SImode, ASHIFTRT, operands);
      DONE;
    }
  else
    FAIL;
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(match_operator:SI 3 "nshift_operator" 
			[ (match_operand:SI 1 "register_operand" "0,0")
			  (match_operand:HI 2 "general_operand" "J,dan")]))
   (clobber (match_scratch:HI 4 "=X,&d"))]
  ""
  "* return emit_a_shift (insn, operands);"
  [(set_attr "cc" "clobber")])

;; ----------------------------------------------------------------------
;; PROLOGUE/EPILOGUE
;; ----------------------------------------------------------------------
(define_expand "prologue"
  [(const_int 0)]
  ""
  "expand_prologue (); DONE;")

(define_expand "epilogue"
  [(return)]
  ""
  "
{
  expand_epilogue ();
  DONE;
}")

(define_insn "return"
  [(return)]
  "reload_completed && total_frame_size () == 0
   && !current_function_needs_context"
  "*
{
  rtx next = next_active_insn (insn);

  if (next
      && GET_CODE (next) == JUMP_INSN
      && GET_CODE (PATTERN (next)) == RETURN)
    return \"\";
  return \"rts\";
}"
  [(set_attr "cc" "clobber")])

(define_insn "return_internal"
  [(const_int 0)
   (return)]
  ""
  "rts"
  [(set_attr "cc" "clobber")])

;; These are special combiner patterns to improve array/pointer accesses.
;;
;; A typical sequence involves extending an integer/char, shifting it left
;; a few times, then truncating the value to PSImode.
;;
;; This first pattern combines the shifting & truncation operations, by
;; itself it is a win because the shifts end up occuring in PSImode instead
;; of SImode.  However, it has the secondary effect of giving us the
;; opportunity to match patterns which allow us to remove the initial
;; extension completely, which is a big win.
(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,a")
	(truncate:PSI
	  (ashift:SI (match_operand:SI 1 "general_operand" "d,m,m")
		     (match_operand:HI 2 "const_int_operand" "i,i,i"))))]
  ""
  "*
{
  int count = INTVAL (operands[2]);
  if (which_alternative == 0)
    output_asm_insn (\"jsr ___truncsipsi2_%1_%0\", operands);
  else if (which_alternative == 1)
    output_asm_insn (\"movx %A1,%0\", operands);
  else
    output_asm_insn (\" mov %1,%0\", operands);

  while (count)
    {
      output_asm_insn (\"add %0,%0\", operands);
      count--;
    }
  return \"\";
}"
  [(set_attr "cc" "clobber")])

;; Similarly, except that we also have zero/sign extension of the
;; original operand.  */
(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d")
	(truncate:PSI
	  (ashift:SI
	    (zero_extend:SI (match_operand:HI 1 "general_operand" "0,dm"))
	    (match_operand:HI 2 "const_int_operand" "i,i"))))]
  ""
  "*
{
  int count = INTVAL (operands[2]);

  /* First extend operand 1 to PSImode.  */
  if (which_alternative == 0)
    output_asm_insn (\"extxu %0\", operands);
  else
    output_asm_insn (\"mov %1,%0\;extxu %0\", operands);

  /* Now do the shifting.  */
  while (count)
    {
      output_asm_insn (\"add %0,%0\", operands);
      count--;
    }
  return \"\";
}"
  [(set_attr "cc" "clobber")])

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(truncate:PSI
	  (ashift:SI
	    (sign_extend:SI (match_operand:HI 1 "general_operand" "0,d,m"))
	    (match_operand:HI 2 "const_int_operand" "i,i,i"))))]
  ""
  "*
{
  int count = INTVAL (operands[2]);

  /* First extend operand 1 to PSImode.  */
  if (which_alternative == 0)
    output_asm_insn (\"extx %0\", operands);
  else if (which_alternative == 1)
    output_asm_insn (\"mov %1,%0\;extx %0\", operands);
  else
    output_asm_insn (\"mov %1,%0\", operands);

  /* Now do the shifting.  */
  while (count)
    {
      output_asm_insn (\"add %0,%0\", operands);
      count--;
    }
  return \"\";
}"
  [(set_attr "cc" "clobber")])

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(truncate:PSI
	  (ashift:SI
	    (sign_extend:SI
	      (zero_extend:HI (match_operand:QI 1 "general_operand" "0,d,m")))
	    (match_operand:HI 2 "const_int_operand" "i,i,i"))))]
  ""
  "*
{
  int count = INTVAL (operands[2]);

  /* First extend operand 1 to PSImode.  */
  if (which_alternative == 0)
    output_asm_insn (\"extxbu %0\", operands);
  else if (which_alternative == 1)
    output_asm_insn (\"mov %1,%0\;extxbu %0\", operands);
  else
    output_asm_insn (\"movbu %1,%0\", operands);

  /* Now do the shifting.  */
  while (count)
    {
      output_asm_insn (\"add %0,%0\", operands);
      count--;
    }
  return \"\";
}"
  [(set_attr "cc" "clobber")])

(define_insn ""
  [(set (match_operand:PSI 0 "general_operand" "=d,d,d")
	(truncate:PSI
	  (ashift:SI
	    (sign_extend:SI
	      (match_operand:QI 1 "general_operand" "0,d,m"))
	    (match_operand:HI 2 "const_int_operand" "i,i,i"))))]
  ""
  "*
{
  int count = INTVAL (operands[2]);

  /* First extend operand 1 to PSImode.  */
  if (which_alternative == 0)
    output_asm_insn (\"extxb %0\", operands);
  else if (which_alternative == 1)
    output_asm_insn (\"mov %1,%0\;extxb %0\", operands);
  else if (GET_CODE (XEXP (operands[1], 0)) == REG)
    output_asm_insn (\"movbu %1,%0\;extxb %0\", operands);
  else
    output_asm_insn (\"movb %1,%0\", operands);

  /* Now do the shifting.  */
  while (count)
    {
      output_asm_insn (\"add %0,%0\", operands);
      count--;
    }
  return \"\";
}"
  [(set_attr "cc" "clobber")])

;; Try to combine consecutive updates of the stack pointer (or any
;; other register for that matter).
(define_peephole
  [(set (match_operand:PSI 0 "register_operand" "=da")
	(plus:PSI (match_dup 0)
		  (match_operand 1 "const_int_operand" "")))
   (set (match_dup 0)
	(plus:PSI (match_dup 0)
		  (match_operand 2 "const_int_operand" "")))]
  ""
  "*
{
  operands[1] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[1]));
  return \"add %1,%0\";
}"
  [(set_attr "cc" "clobber")])

;;
;; We had patterns to check eq/ne, but the they don't work because
;; 0x80000000 + 0x80000000 = 0x0 with a carry out.
;;
;; The Z flag and C flag would be set, and we have no way to
;; check for the Z flag set and C flag clear.
;;
;; This will work on the mn10200 because we can check the ZX flag
;; if the comparison is in HImode.
(define_peephole
  [(set (cc0) (match_operand:HI 0 "register_operand" "d"))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
			   (match_operand 1 "" "")
			   (pc)))]
  "dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])"
  "add %0,%0\;bcc %1"
  [(set_attr "cc" "clobber")])

(define_peephole
  [(set (cc0) (match_operand:HI 0 "register_operand" "d"))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
			   (match_operand 1 "" "")
			   (pc)))]
  "dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])"
  "add %0,%0\;bcs %1"
  [(set_attr "cc" "clobber")])

(define_peephole
  [(set (cc0) (match_operand:HI 0 "register_operand" "d"))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
			   (pc)
			   (match_operand 1 "" "")))]
  "dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])"
  "add %0,%0\;bcs %1"
  [(set_attr "cc" "clobber")])

(define_peephole
  [(set (cc0) (match_operand:HI 0 "register_operand" "d"))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
			   (pc)
			   (match_operand 1 "" "")))]
  "dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])"
  "add %0,%0\;bcc %1"
  [(set_attr "cc" "clobber")])

(define_peephole
  [(set (cc0) (match_operand:PSI 0 "register_operand" "d"))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
			   (match_operand 1 "" "")
			   (pc)))]
  "dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])"
  "add %0,%0\;bccx %1"
  [(set_attr "cc" "clobber")])

(define_peephole
  [(set (cc0) (match_operand:PSI 0 "register_operand" "d"))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
			   (match_operand 1 "" "")
			   (pc)))]
  "dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])"
  "add %0,%0\;bcsx %1"
  [(set_attr "cc" "clobber")])

(define_peephole
  [(set (cc0) (match_operand:PSI 0 "register_operand" "d"))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
			   (pc)
			   (match_operand 1 "" "")))]
  "dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])"
  "add %0,%0\;bcsx %1"
  [(set_attr "cc" "clobber")])

(define_peephole
  [(set (cc0) (match_operand:PSI 0 "register_operand" "d"))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
			   (pc)
			   (match_operand 1 "" "")))]
  "dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])"
  "add %0,%0\;bccx %1"
  [(set_attr "cc" "clobber")])
;; END CYGNUS LOCAL
