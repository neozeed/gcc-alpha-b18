This is Info file g77.info, produced by Makeinfo version 1.68 from the
input file g77.texi.

   This file explains how to use the GNU Fortran system.

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1995-1997 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License," "Funding for
Free Software," and "Protect Your Freedom--Fight `Look And Feel'" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License," "Funding for Free Software," and "Protect Your Freedom--Fight
`Look And Feel'", and this permission notice, may be included in
translations approved by the Free Software Foundation instead of in the
original English.

   Contributed by James Craig Burley (<burley@gnu.ai.mit.edu>).
Inspired by a first pass at translating `g77-0.5.16/f/DOC' that was
contributed to Craig by David Ronis (<ronis@onsager.chem.mcgill.ca>).

INFO-DIR-SECTION Fortran Programming
START-INFO-DIR-ENTRY
* g77: (g77).               The GNU Fortran compilation system.
END-INFO-DIR-ENTRY


File: g77.info,  Node: Ugly Assigned Labels,  Prev: Ugly Integer Conversions,  Up: Distensions

Ugly Assigned Labels
--------------------

   The `-fugly-assign' option forces `g77' to use the same storage for
assigned labels as it would for a normal assignment to the same
variable.

   For example, consider the following code fragment:

     I = 3
     ASSIGN 10 TO I

Normally, for portability and improved diagnostics, `g77' reserves
distinct storage for a "sibling" of `I', used only for `ASSIGN'
statements to that variable (along with the corresponding
assigned-`GOTO' and assigned-`FORMAT'-I/O statements that reference the
variable).

   However, some code (that violates the ANSI FORTRAN 77 standard)
attempts to copy assigned labels among variables involved with `ASSIGN'
statements, as in:

     ASSIGN 10 TO I
     ISTATE(5) = I
     ...
     J = ISTATE(ICUR)
     GOTO J

Such code doesn't work under `g77' unless `-fugly-assign' is specified
on the command-line, ensuring that the value of `I' referenced in the
second line is whatever value `g77' uses to designate statement label
`10', so the value may be copied into the `ISTATE' array, later
retrieved into a variable of the appropriate type (`J'), and used as
the target of an assigned-`GOTO' statement.

   *Note:* To avoid subtle program bugs, when `-fugly-assign' is
specified, `g77' requires the type of variables specified in
assigned-label contexts *must* be the same type returned by `%LOC()'.
On many systems, this type is effectively the same as
`INTEGER(KIND=1)', while, on others, it is effectively the same as
`INTEGER(KIND=2)'.

   Do *not* depend on `g77' actually writing valid pointers to these
variables, however.  While `g77' currently chooses that implementation,
it might be changed in the future.

   *Note Assigned Statement Labels (ASSIGN and GOTO): Assigned
Statement Labels, for implementation details on assigned-statement
labels.


File: g77.info,  Node: Compiler,  Next: Other Dialects,  Prev: Language,  Up: Top

The GNU Fortran Compiler
************************

   The GNU Fortran compiler, `g77', supports programs written in the
GNU Fortran language and in some other dialects of Fortran.

   Some aspects of how `g77' works are universal regardless of dialect,
and yet are not properly part of the GNU Fortran language itself.
These are described below.

   *Note: This portion of the documentation definitely needs a lot of
work!*

* Menu:

* Compiler Limits::
* Compiler Types::
* Compiler Constants::
* Compiler Intrinsics::


File: g77.info,  Node: Compiler Limits,  Next: Compiler Types,  Up: Compiler

Compiler Limits
===============

   `g77', as with GNU tools in general, imposes few arbitrary
restrictions on lengths of identifiers, number of continuation lines,
number of external symbols in a program, and so on.

   For example, some other Fortran compiler have an option (such as
`-NlX') to increase the limit on the number of continuation lines.
Also, some Fortran compilation systems have an option (such as `-NxX')
to increase the limit on the number of external symbols.

   `g77', `gcc', and GNU `ld' (the GNU linker) have no equivalent
options, since they do not impose arbitrary limits in these areas.

   `g77' does currently limit the number of dimensions in an array to
the same degree as do the Fortran standards--seven (7).  This
restriction might well be lifted in a future version.


File: g77.info,  Node: Compiler Types,  Next: Compiler Constants,  Prev: Compiler Limits,  Up: Compiler

Compiler Types
==============

   Fortran implementations have a fair amount of freedom given them by
the standard as far as how much storage space is used and how much
precision and range is offered by the various types such as
`LOGICAL(KIND=1)', `INTEGER(KIND=1)', `REAL(KIND=1)', `REAL(KIND=2)',
`COMPLEX(KIND=1)', and `CHARACTER'.  Further, many compilers offer
so-called `*N' notation, but the interpretation of N varies across
compilers and target architectures.

   The standard requires that `LOGICAL(KIND=1)', `INTEGER(KIND=1)', and
`REAL(KIND=1)' occupy the same amount of storage space, and that
`COMPLEX(KIND=1)' and `REAL(KIND=2)' take twice as much storage space
as `REAL(KIND=1)'.  Further, it requires that `COMPLEX(KIND=1)'
entities be ordered such that when a `COMPLEX(KIND=1)' variable is
storage-associated (such as via `EQUIVALENCE') with a two-element
`REAL(KIND=1)' array named `R', `R(1)' corresponds to the real element
and `R(2)' to the imaginary element of the `COMPLEX(KIND=1)' variable.

   (Few requirements as to precision or ranges of any of these are
placed on the implementation, nor is the relationship of storage sizes
of these types to the `CHARACTER' type specified, by the standard.)

   `g77' follows the above requirements, warning when compiling a
program requires placement of items in memory that contradict the
requirements of the target architecture.  (For example, a program can
require placement of a `REAL(KIND=2)' on a boundary that is not an even
multiple of its size, but still an even multiple of the size of a
`REAL(KIND=1)' variable.  On some target architectures, using the
canonical mapping of Fortran types to underlying architectural types,
such placement is prohibited by the machine definition or the
Application Binary Interface (ABI) in force for the configuration
defined for building `gcc' and `g77'.  `g77' warns about such
situations when it encounters them.)

   `g77' follows consistent rules for configuring the mapping between
Fortran types, including the `*N' notation, and the underlying
architectural types as accessed by a similarly-configured applicable
version of the `gcc' compiler.  These rules offer a widely portable,
consistent Fortran/C environment, although they might well conflict
with the expectations of users of Fortran compilers designed and
written for particular architectures.

   These rules are based on the configuration that is in force for the
version of `gcc' built in the same release as `g77' (and which was
therefore used to build both the `g77' compiler components and the
`libf2c' run-time library):

`REAL(KIND=1)'
     Same as `float' type.

`REAL(KIND=2)'
     Same as whatever floating-point type that is twice the size of a
     `float'--usually, this is a `double'.

`INTEGER(KIND=1)'
     Same as an integral type that is occupies the same amount of
     memory storage as `float'--usually, this is either an `int' or a
     `long int'.

`LOGICAL(KIND=1)'
     Same `gcc' type as `INTEGER(KIND=1)'.

`INTEGER(KIND=2)'
     Twice the size, and usually nearly twice the range, as
     `INTEGER(KIND=1)'--usually, this is either a `long int' or a `long
     long int'.

`LOGICAL(KIND=2)'
     Same `gcc' type as `INTEGER(KIND=2)'.

`INTEGER(KIND=3)'
     Same `gcc' type as signed `char'.

`LOGICAL(KIND=3)'
     Same `gcc' type as `INTEGER(KIND=3)'.

`INTEGER(KIND=6)'
     Twice the size, and usually nearly twice the range, as
     `INTEGER(KIND=3)'--usually, this is a `short'.

`LOGICAL(KIND=6)'
     Same `gcc' type as `INTEGER(KIND=6)'.

`COMPLEX(KIND=1)'
     Two `REAL(KIND=1)' scalars (one for the real part followed by one
     for the imaginary part).

`COMPLEX(KIND=2)'
     Two `REAL(KIND=2)' scalars.

`NUMERIC-TYPE*N'
     (Where NUMERIC-TYPE is any type other than `CHARACTER'.)  Same as
     whatever `gcc' type occupies N times the storage space of a `gcc'
     `char' item.

`DOUBLE PRECISION'
     Same as `REAL(KIND=2)'.

`DOUBLE COMPLEX'
     Same as `COMPLEX(KIND=2)'.

   Note that the above are proposed correspondences and might change in
future versions of `g77'--avoid writing code depending on them.

   Other types supported by `g77' are derived from gcc types such as
`char', `short', `int', `long int', `long long int', `long double', and
so on.  That is, whatever types `gcc' already supports, `g77' supports
now or probably will support in a future version.  The rules for the
`NUMERIC-TYPE*N' notation apply to these types, and new values for
`NUMERIC-TYPE(KIND=N)' will be assigned in a way that encourages
clarity, consistency, and portability.


File: g77.info,  Node: Compiler Constants,  Next: Compiler Intrinsics,  Prev: Compiler Types,  Up: Compiler

Compiler Constants
==================

   `g77' strictly assigns types to *all* constants not documented as
"typeless" (typeless constants including `'1'Z', for example).  Many
other Fortran compilers attempt to assign types to typed constants
based on their context.  This results in hard-to-find bugs, nonportable
code, and is not in the spirit (though it strictly follows the letter)
of the 77 and 90 standards.

   `g77' might offer, in a future release, explicit constructs by which
a wider variety of typeless constants may be specified, and/or
user-requested warnings indicating places where `g77' might differ from
how other compilers assign types to constants.

   *Note Context-Sensitive Constants::, for more information on this
issue.


File: g77.info,  Node: Compiler Intrinsics,  Prev: Compiler Constants,  Up: Compiler

Compiler Intrinsics
===================

   `g77' offers an ever-widening set of intrinsics.  Currently these
all are procedures (functions and subroutines).

   Some of these intrinsics are unimplemented, but their names reserved
to reduce future problems with existing code as they are implemented.
Others are implemented as part of the GNU Fortran language, while yet
others are provided for compatibility with other dialects of Fortran
but are not part of the GNU Fortran language.

   To manage these distinctions, `g77' provides intrinsic *groups*, a
facility that is simply an extension of the intrinsic groups provided
by the GNU Fortran language.

* Menu:

* Intrinsic Groups::  How intrinsics are grouped for easy management.
* Other Intrinsics::  Intrinsics other than those in the GNU
                       Fortran language.


File: g77.info,  Node: Intrinsic Groups,  Next: Other Intrinsics,  Up: Compiler Intrinsics

Intrinsic Groups
----------------

   A given specific intrinsic belongs in one or more groups.  Each
group is deleted, disabled, hidden, or enabled by default or a
command-line option.  The meaning of each term follows.

Deleted
     No intrinsics are recognized as belonging to that group.

Disabled
     Intrinsics are recognized as belonging to the group, but
     references to them (other than via the `INTRINSIC' statement) are
     disallowed through that group.

Hidden
     Intrinsics in that group are recognized and enabled (if
     implemented) *only* if the first mention of the actual name of an
     intrinsic in a program unit is in an `INTRINSIC' statement.

Enabled
     Intrinsics in that group are recognized and enabled (if
     implemented).

   The distinction between deleting and disabling a group is illustrated
by the following example.  Assume intrinsic `FOO' belongs only to group
`FGR'.  If group `FGR' is deleted, the following program unit will
successfully compile, because `FOO()' will be seen as a reference to an
external function named `FOO':

     PRINT *, FOO()
     END

If group `FGR' is disabled, compiling the above program will produce
diagnostics, either because the `FOO' intrinsic is improperly invoked
or, if properly invoked, it is not enabled.  To change the above
program so it references an external function `FOO' instead of the
disabled `FOO' intrinsic, add the following line to the top:

     EXTERNAL FOO

So, deleting a group tells `g77' to pretend as though the intrinsics in
that group do not exist at all, whereas disabling it tells `g77' to
recognize them as (disabled) intrinsics in intrinsic-like contexts.

   Hiding a group is like enabling it, but the intrinsic must be first
named in an `INTRINSIC' statement to be considered a reference to the
intrinsic rather than to an external procedure.  This might be the
"safest" way to treat a new group of intrinsics when compiling old
code, because it allows the old code to be generally written as if
those new intrinsics never existed, but to be changed to use them by
inserting `INTRINSIC' statements in the appropriate places.  However,
it should be the goal of development to use `EXTERNAL' for all names of
external procedures that might be intrinsic names.

   If an intrinsic is in more than one group, it is enabled if any of
its containing groups are enabled; if not so enabled, it is hidden if
any of its containing groups are hidden; if not so hidden, it is
disabled if any of its containing groups are disabled; if not so
disabled, it is deleted.  This extra complication is necessary because
some intrinsics, such as `IBITS', belong to more than one group, and
hence should be enabled if any of the groups to which they belong are
enabled, and so on.

   The groups are:

`badu77'
     UNIX intrinsics having inappropriate forms (usually functions that
     have intended side effects).

`gnu'
     Intrinsics the GNU Fortran language supports that are extensions to
     the Fortran standards (77 and 90).

`f2c'
     Intrinsics supported by AT&T's `f2c' converter and/or `libf2c'.

`f90'
     Fortran 90 intrinsics.

`mil'
     MIL-STD 1753 intrinsics (`MVBITS', `IAND', `BTEST', and so on).

`unix'
     UNIX intrinsics (`IARGC', `EXIT', `ERF', and so on).

`vxt'
     VAX/VMS FORTRAN (current as of v4) intrinsics.


File: g77.info,  Node: Other Intrinsics,  Prev: Intrinsic Groups,  Up: Compiler Intrinsics

Other Intrinsics
----------------

   `g77' supports intrinsics other than those in the GNU Fortran
language proper.  This set of intrinsics is described below.

   (Note that the empty lines appearing in the menu below are not
intentional--they result from a bug in the `makeinfo' program.)

* Menu:


* ACosD Intrinsic::     (Reserved for future use.)

* AIMax0 Intrinsic::    (Reserved for future use.)
* AIMin0 Intrinsic::    (Reserved for future use.)

* AJMax0 Intrinsic::    (Reserved for future use.)
* AJMin0 Intrinsic::    (Reserved for future use.)

* ASinD Intrinsic::     (Reserved for future use.)

* ATan2D Intrinsic::    (Reserved for future use.)
* ATanD Intrinsic::     (Reserved for future use.)

* BITest Intrinsic::    (Reserved for future use.)

* BJTest Intrinsic::    (Reserved for future use.)

* CDAbs Intrinsic::     Absolute value (archaic).
* CDCos Intrinsic::     Cosine (archaic).
* CDExp Intrinsic::     Exponential (archaic).
* CDLog Intrinsic::     Natural logarithm (archaic).
* CDSin Intrinsic::     Sine (archaic).
* CDSqRt Intrinsic::    Square root (archaic).

* ChDir Intrinsic (function):: Change directory.

* ChMod Intrinsic (function):: Change file modes.

* CosD Intrinsic::      (Reserved for future use.)

* DACosD Intrinsic::    (Reserved for future use.)

* DASinD Intrinsic::    (Reserved for future use.)

* DATan2D Intrinsic::   (Reserved for future use.)
* DATanD Intrinsic::    (Reserved for future use.)
* Date Intrinsic::      Get current date as dd-Mon-yy.

* DbleQ Intrinsic::     (Reserved for future use.)

* DCmplx Intrinsic::    Construct `COMPLEX(KIND=2)' value.
* DConjg Intrinsic::    Complex conjugate (archaic).

* DCosD Intrinsic::     (Reserved for future use.)

* DFloat Intrinsic::    Conversion (archaic).

* DFlotI Intrinsic::    (Reserved for future use.)
* DFlotJ Intrinsic::    (Reserved for future use.)

* DImag Intrinsic::     Convert/extract imaginary part of complex (archaic).

* DReal Intrinsic::     Convert value to type `REAL(KIND=2)'.

* DSinD Intrinsic::     (Reserved for future use.)

* DTanD Intrinsic::     (Reserved for future use.)

* Dtime Intrinsic (function):: Get elapsed time since last time.

* FGet Intrinsic (function):: Read a character from unit 5 stream-wise.

* FGetC Intrinsic (function):: Read a character stream-wise.

* FloatI Intrinsic::    (Reserved for future use.)
* FloatJ Intrinsic::    (Reserved for future use.)

* FPut Intrinsic (function):: Write a character to unit 6 stream-wise.

* FPutC Intrinsic (function):: Write a character stream-wise.

* IDate Intrinsic (VXT):: Get local time info (VAX/VMS).

* IIAbs Intrinsic::     (Reserved for future use.)
* IIAnd Intrinsic::     (Reserved for future use.)
* IIBClr Intrinsic::    (Reserved for future use.)
* IIBits Intrinsic::    (Reserved for future use.)
* IIBSet Intrinsic::    (Reserved for future use.)
* IIDiM Intrinsic::     (Reserved for future use.)
* IIDInt Intrinsic::    (Reserved for future use.)
* IIDNnt Intrinsic::    (Reserved for future use.)
* IIEOr Intrinsic::     (Reserved for future use.)
* IIFix Intrinsic::     (Reserved for future use.)
* IInt Intrinsic::      (Reserved for future use.)
* IIOr Intrinsic::      (Reserved for future use.)
* IIQint Intrinsic::    (Reserved for future use.)
* IIQNnt Intrinsic::    (Reserved for future use.)
* IIShftC Intrinsic::   (Reserved for future use.)
* IISign Intrinsic::    (Reserved for future use.)

* IMax0 Intrinsic::     (Reserved for future use.)
* IMax1 Intrinsic::     (Reserved for future use.)
* IMin0 Intrinsic::     (Reserved for future use.)
* IMin1 Intrinsic::     (Reserved for future use.)
* IMod Intrinsic::      (Reserved for future use.)

* INInt Intrinsic::     (Reserved for future use.)
* INot Intrinsic::      (Reserved for future use.)

* IZExt Intrinsic::     (Reserved for future use.)
* JIAbs Intrinsic::     (Reserved for future use.)
* JIAnd Intrinsic::     (Reserved for future use.)
* JIBClr Intrinsic::    (Reserved for future use.)
* JIBits Intrinsic::    (Reserved for future use.)
* JIBSet Intrinsic::    (Reserved for future use.)
* JIDiM Intrinsic::     (Reserved for future use.)
* JIDInt Intrinsic::    (Reserved for future use.)
* JIDNnt Intrinsic::    (Reserved for future use.)
* JIEOr Intrinsic::     (Reserved for future use.)
* JIFix Intrinsic::     (Reserved for future use.)
* JInt Intrinsic::      (Reserved for future use.)
* JIOr Intrinsic::      (Reserved for future use.)
* JIQint Intrinsic::    (Reserved for future use.)
* JIQNnt Intrinsic::    (Reserved for future use.)
* JIShft Intrinsic::    (Reserved for future use.)
* JIShftC Intrinsic::   (Reserved for future use.)
* JISign Intrinsic::    (Reserved for future use.)
* JMax0 Intrinsic::     (Reserved for future use.)
* JMax1 Intrinsic::     (Reserved for future use.)
* JMin0 Intrinsic::     (Reserved for future use.)
* JMin1 Intrinsic::     (Reserved for future use.)
* JMod Intrinsic::      (Reserved for future use.)
* JNInt Intrinsic::     (Reserved for future use.)
* JNot Intrinsic::      (Reserved for future use.)
* JZExt Intrinsic::     (Reserved for future use.)

* Kill Intrinsic (function):: Signal a process.

* Link Intrinsic (function):: Make hard link in file system.

* QAbs Intrinsic::      (Reserved for future use.)
* QACos Intrinsic::     (Reserved for future use.)
* QACosD Intrinsic::    (Reserved for future use.)
* QASin Intrinsic::     (Reserved for future use.)
* QASinD Intrinsic::    (Reserved for future use.)
* QATan Intrinsic::     (Reserved for future use.)
* QATan2 Intrinsic::    (Reserved for future use.)
* QATan2D Intrinsic::   (Reserved for future use.)
* QATanD Intrinsic::    (Reserved for future use.)
* QCos Intrinsic::      (Reserved for future use.)
* QCosD Intrinsic::     (Reserved for future use.)
* QCosH Intrinsic::     (Reserved for future use.)
* QDiM Intrinsic::      (Reserved for future use.)
* QExp Intrinsic::      (Reserved for future use.)
* QExt Intrinsic::      (Reserved for future use.)
* QExtD Intrinsic::     (Reserved for future use.)
* QFloat Intrinsic::    (Reserved for future use.)
* QInt Intrinsic::      (Reserved for future use.)
* QLog Intrinsic::      (Reserved for future use.)
* QLog10 Intrinsic::    (Reserved for future use.)
* QMax1 Intrinsic::     (Reserved for future use.)
* QMin1 Intrinsic::     (Reserved for future use.)
* QMod Intrinsic::      (Reserved for future use.)
* QNInt Intrinsic::     (Reserved for future use.)
* QSin Intrinsic::      (Reserved for future use.)
* QSinD Intrinsic::     (Reserved for future use.)
* QSinH Intrinsic::     (Reserved for future use.)
* QSqRt Intrinsic::     (Reserved for future use.)
* QTan Intrinsic::      (Reserved for future use.)
* QTanD Intrinsic::     (Reserved for future use.)
* QTanH Intrinsic::     (Reserved for future use.)

* Rename Intrinsic (function):: Rename file.

* Secnds Intrinsic::    Get local time offset since midnight.

* Signal Intrinsic (function):: Muck with signal handling.

* SinD Intrinsic::      (Reserved for future use.)

* SnglQ Intrinsic::     (Reserved for future use.)

* SymLnk Intrinsic (function):: Make symbolic link in file system.

* System Intrinsic (function):: Invoke shell (system) command.

* TanD Intrinsic::      (Reserved for future use.)

* Time Intrinsic (VXT):: Get the time as a character value.

* UMask Intrinsic (function):: Set file creation permissions mask.

* Unlink Intrinsic (function):: Unlink file.

* ZExt Intrinsic::      (Reserved for future use.)


File: g77.info,  Node: ACosD Intrinsic,  Next: AIMax0 Intrinsic,  Up: Other Intrinsics

ACosD Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL ACosD' to use this name for an
external procedure.


File: g77.info,  Node: AIMax0 Intrinsic,  Next: AIMin0 Intrinsic,  Prev: ACosD Intrinsic,  Up: Other Intrinsics

AIMax0 Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL AIMax0' to use this name for an
external procedure.


File: g77.info,  Node: AIMin0 Intrinsic,  Next: AJMax0 Intrinsic,  Prev: AIMax0 Intrinsic,  Up: Other Intrinsics

AIMin0 Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL AIMin0' to use this name for an
external procedure.


File: g77.info,  Node: AJMax0 Intrinsic,  Next: AJMin0 Intrinsic,  Prev: AIMin0 Intrinsic,  Up: Other Intrinsics

AJMax0 Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL AJMax0' to use this name for an
external procedure.


File: g77.info,  Node: AJMin0 Intrinsic,  Next: ASinD Intrinsic,  Prev: AJMax0 Intrinsic,  Up: Other Intrinsics

AJMin0 Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL AJMin0' to use this name for an
external procedure.


File: g77.info,  Node: ASinD Intrinsic,  Next: ATan2D Intrinsic,  Prev: AJMin0 Intrinsic,  Up: Other Intrinsics

ASinD Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL ASinD' to use this name for an
external procedure.


File: g77.info,  Node: ATan2D Intrinsic,  Next: ATanD Intrinsic,  Prev: ASinD Intrinsic,  Up: Other Intrinsics

ATan2D Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL ATan2D' to use this name for an
external procedure.


File: g77.info,  Node: ATanD Intrinsic,  Next: BITest Intrinsic,  Prev: ATan2D Intrinsic,  Up: Other Intrinsics

ATanD Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL ATanD' to use this name for an
external procedure.


File: g77.info,  Node: BITest Intrinsic,  Next: BJTest Intrinsic,  Prev: ATanD Intrinsic,  Up: Other Intrinsics

BITest Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL BITest' to use this name for an
external procedure.


File: g77.info,  Node: BJTest Intrinsic,  Next: CDAbs Intrinsic,  Prev: BITest Intrinsic,  Up: Other Intrinsics

BJTest Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL BJTest' to use this name for an
external procedure.


File: g77.info,  Node: CDAbs Intrinsic,  Next: CDCos Intrinsic,  Prev: BJTest Intrinsic,  Up: Other Intrinsics

CDAbs Intrinsic
...............

     CDAbs(A)

CDAbs: `REAL(KIND=2)' function.

A: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `ABS()' that is specific to one type for A.  *Note
Abs Intrinsic::.


File: g77.info,  Node: CDCos Intrinsic,  Next: CDExp Intrinsic,  Prev: CDAbs Intrinsic,  Up: Other Intrinsics

CDCos Intrinsic
...............

     CDCos(X)

CDCos: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `COS()' that is specific to one type for X.  *Note
Cos Intrinsic::.


File: g77.info,  Node: CDExp Intrinsic,  Next: CDLog Intrinsic,  Prev: CDCos Intrinsic,  Up: Other Intrinsics

CDExp Intrinsic
...............

     CDExp(X)

CDExp: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `EXP()' that is specific to one type for X.  *Note
Exp Intrinsic::.


File: g77.info,  Node: CDLog Intrinsic,  Next: CDSin Intrinsic,  Prev: CDExp Intrinsic,  Up: Other Intrinsics

CDLog Intrinsic
...............

     CDLog(X)

CDLog: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `LOG()' that is specific to one type for X.  *Note
Log Intrinsic::.


File: g77.info,  Node: CDSin Intrinsic,  Next: CDSqRt Intrinsic,  Prev: CDLog Intrinsic,  Up: Other Intrinsics

CDSin Intrinsic
...............

     CDSin(X)

CDSin: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `SIN()' that is specific to one type for X.  *Note
Sin Intrinsic::.


File: g77.info,  Node: CDSqRt Intrinsic,  Next: ChDir Intrinsic (function),  Prev: CDSin Intrinsic,  Up: Other Intrinsics

CDSqRt Intrinsic
................

     CDSqRt(X)

CDSqRt: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `SQRT()' that is specific to one type for X.  *Note
SqRt Intrinsic::.


File: g77.info,  Node: ChDir Intrinsic (function),  Next: ChMod Intrinsic (function),  Prev: CDSqRt Intrinsic,  Up: Other Intrinsics

ChDir Intrinsic (function)
..........................

     ChDir(DIR)

ChDir: `INTEGER(KIND=1)' function.

DIR: `CHARACTER'; scalar; INTENT(IN).

Intrinsic groups: `badu77'.

Description:

   Sets the current working directory to be DIR.  Returns 0 on success
or a non-zero error code.  See `chdir(3)'.

   Due to the side effects performed by this intrinsic, the function
form is not recommended.

   For information on other intrinsics with the same name: *Note ChDir
Intrinsic (subroutine)::.


File: g77.info,  Node: ChMod Intrinsic (function),  Next: CosD Intrinsic,  Prev: ChDir Intrinsic (function),  Up: Other Intrinsics

ChMod Intrinsic (function)
..........................

     ChMod(NAME, MODE)

ChMod: `INTEGER(KIND=1)' function.

NAME: `CHARACTER'; scalar; INTENT(IN).

MODE: `CHARACTER'; scalar; INTENT(IN).

Intrinsic groups: `badu77'.

Description:

   Changes the access mode of file NAME according to the specification
MODE, which is given in the format of `chmod(1)'.  A null character
(`CHAR(0)') marks the end of the name in NAME--otherwise, trailing
blanks in NAME are ignored.  Currently, NAME must not contain the
single quote character.

   Returns 0 on success or a non-zero error code otherwise.

   Note that this currently works by actually invoking `/bin/chmod' (or
the `chmod' found when the library was configured) and so may fail in
some circumstances and will, anyway, be slow.

   Due to the side effects performed by this intrinsic, the function
form is not recommended.

   For information on other intrinsics with the same name: *Note ChMod
Intrinsic (subroutine)::.


File: g77.info,  Node: CosD Intrinsic,  Next: DACosD Intrinsic,  Prev: ChMod Intrinsic (function),  Up: Other Intrinsics

CosD Intrinsic
..............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL CosD' to use this name for an
external procedure.


File: g77.info,  Node: DACosD Intrinsic,  Next: DASinD Intrinsic,  Prev: CosD Intrinsic,  Up: Other Intrinsics

DACosD Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DACosD' to use this name for an
external procedure.


File: g77.info,  Node: DASinD Intrinsic,  Next: DATan2D Intrinsic,  Prev: DACosD Intrinsic,  Up: Other Intrinsics

DASinD Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DASinD' to use this name for an
external procedure.


File: g77.info,  Node: DATan2D Intrinsic,  Next: DATanD Intrinsic,  Prev: DASinD Intrinsic,  Up: Other Intrinsics

DATan2D Intrinsic
.................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DATan2D' to use this name for
an external procedure.


File: g77.info,  Node: DATanD Intrinsic,  Next: Date Intrinsic,  Prev: DATan2D Intrinsic,  Up: Other Intrinsics

DATanD Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DATanD' to use this name for an
external procedure.


File: g77.info,  Node: Date Intrinsic,  Next: DbleQ Intrinsic,  Prev: DATanD Intrinsic,  Up: Other Intrinsics

Date Intrinsic
..............

     CALL Date(DATE)

DATE: `CHARACTER'; scalar; INTENT(OUT).

Intrinsic groups: `vxt'.

Description:

   Returns DATE in the form `DD-MMM-YY', representing the numeric day
of the month DD, a three-character abbreviation of the month name MMM
and the last two digits of the year YY, e.g. `25-Nov-96'.

   This intrinsic is not recommended, due to the year 2000 approaching.
*Note CTime Intrinsic (subroutine)::, for information on obtaining more
digits for the current (or any) date.


File: g77.info,  Node: DbleQ Intrinsic,  Next: DCmplx Intrinsic,  Prev: Date Intrinsic,  Up: Other Intrinsics

DbleQ Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DbleQ' to use this name for an
external procedure.


File: g77.info,  Node: DCmplx Intrinsic,  Next: DConjg Intrinsic,  Prev: DbleQ Intrinsic,  Up: Other Intrinsics

DCmplx Intrinsic
................

     DCmplx(X, Y)

DCmplx: `COMPLEX(KIND=2)' function.

X: `INTEGER', `REAL', or `COMPLEX'; scalar; INTENT(IN).

Y: `INTEGER' or `REAL'; OPTIONAL (must be omitted if X is `COMPLEX');
scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   If X is not type `COMPLEX', constructs a value of type
`COMPLEX(KIND=2)' from the real and imaginary values specified by X and
Y, respectively.  If Y is omitted, `0D0' is assumed.

   If X is type `COMPLEX', converts it to type `COMPLEX(KIND=2)'.

   Although this intrinsic is not standard Fortran, it is a popular
extension offered by many compilers that support `DOUBLE COMPLEX',
since it offers the easiest way to convert to `DOUBLE COMPLEX' without
using Fortran 90 features (such as the `KIND=' argument to the
`CMPLX()' intrinsic).

   (`CMPLX(0D0, 0D0)' returns a single-precision `COMPLEX' result, as
required by standard FORTRAN 77.  That's why so many compilers provide
`DCMPLX()', since `DCMPLX(0D0, 0D0)' returns a `DOUBLE COMPLEX' result.
Still, `DCMPLX()' converts even `REAL*16' arguments to their `REAL*8'
equivalents in most dialects of Fortran, so neither it nor `CMPLX()'
allow easy construction of arbitrary-precision values without
potentially forcing a conversion involving extending or reducing
precision.  GNU Fortran provides such an intrinsic, called `COMPLEX()'.)

   *Note Complex Intrinsic::, for information on easily constructing a
`COMPLEX' value of arbitrary precision from `REAL' arguments.


File: g77.info,  Node: DConjg Intrinsic,  Next: DCosD Intrinsic,  Prev: DCmplx Intrinsic,  Up: Other Intrinsics

DConjg Intrinsic
................

     DConjg(Z)

DConjg: `COMPLEX(KIND=2)' function.

Z: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `CONJG()' that is specific to one type for Z.  *Note
Conjg Intrinsic::.


File: g77.info,  Node: DCosD Intrinsic,  Next: DFloat Intrinsic,  Prev: DConjg Intrinsic,  Up: Other Intrinsics

DCosD Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DCosD' to use this name for an
external procedure.


File: g77.info,  Node: DFloat Intrinsic,  Next: DFlotI Intrinsic,  Prev: DCosD Intrinsic,  Up: Other Intrinsics

DFloat Intrinsic
................

     DFloat(A)

DFloat: `REAL(KIND=2)' function.

A: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `REAL()' that is specific to one type for A.  *Note
Real Intrinsic::.


File: g77.info,  Node: DFlotI Intrinsic,  Next: DFlotJ Intrinsic,  Prev: DFloat Intrinsic,  Up: Other Intrinsics

DFlotI Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DFlotI' to use this name for an
external procedure.


File: g77.info,  Node: DFlotJ Intrinsic,  Next: DImag Intrinsic,  Prev: DFlotI Intrinsic,  Up: Other Intrinsics

DFlotJ Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DFlotJ' to use this name for an
external procedure.


File: g77.info,  Node: DImag Intrinsic,  Next: DReal Intrinsic,  Prev: DFlotJ Intrinsic,  Up: Other Intrinsics

DImag Intrinsic
...............

     DImag(Z)

DImag: `REAL(KIND=2)' function.

Z: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `AIMAG()' that is specific to one type for Z.  *Note
AImag Intrinsic::.


File: g77.info,  Node: DReal Intrinsic,  Next: DSinD Intrinsic,  Prev: DImag Intrinsic,  Up: Other Intrinsics

DReal Intrinsic
...............

     DReal(A)

DReal: `REAL(KIND=2)' function.

A: `INTEGER', `REAL', or `COMPLEX'; scalar; INTENT(IN).

Intrinsic groups: `vxt'.

Description:

   Converts A to `REAL(KIND=2)'.

   If A is type `COMPLEX', its real part is converted (if necessary) to
`REAL(KIND=2)', and its imaginary part is disregarded.

   Although this intrinsic is not standard Fortran, it is a popular
extension offered by many compilers that support `DOUBLE COMPLEX',
since it offers the easiest way to extract the real part of a `DOUBLE
COMPLEX' value without using the Fortran 90 `REAL()' intrinsic in a way
that produces a return value inconsistent with the way many FORTRAN 77
compilers handle `REAL()' of a `DOUBLE COMPLEX' value.

   *Note RealPart Intrinsic::, for information on a GNU Fortran
intrinsic that avoids these areas of confusion.

   *Note Dble Intrinsic::, for information on the standard FORTRAN 77
replacement for `DREAL()'.

   *Note REAL() and AIMAG() of Complex::, for more information on this
issue.


File: g77.info,  Node: DSinD Intrinsic,  Next: DTanD Intrinsic,  Prev: DReal Intrinsic,  Up: Other Intrinsics

DSinD Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DSinD' to use this name for an
external procedure.


File: g77.info,  Node: DTanD Intrinsic,  Next: Dtime Intrinsic (function),  Prev: DSinD Intrinsic,  Up: Other Intrinsics

DTanD Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL DTanD' to use this name for an
external procedure.


File: g77.info,  Node: Dtime Intrinsic (function),  Next: FGet Intrinsic (function),  Prev: DTanD Intrinsic,  Up: Other Intrinsics

Dtime Intrinsic (function)
..........................

     Dtime(TARRAY)

Dtime: `REAL(KIND=1)' function.

TARRAY: `REAL(KIND=1)'; DIMENSION(2); INTENT(OUT).

Intrinsic groups: `badu77'.

Description:

   Initially, return the number of seconds of runtime since the start
of the process's execution as the function value, and the user and
system components of this in `TARRAY(1)' and `TARRAY(2)' respectively.
The functions' value is equal to `TARRAY(1) + TARRAY(2)'.

   Subsequent invocations of `DTIME()' return values accumulated since
the previous invocation.

   Due to the side effects performed by this intrinsic, the function
form is not recommended.

   For information on other intrinsics with the same name: *Note Dtime
Intrinsic (subroutine)::.


File: g77.info,  Node: FGet Intrinsic (function),  Next: FGetC Intrinsic (function),  Prev: Dtime Intrinsic (function),  Up: Other Intrinsics

FGet Intrinsic (function)
.........................

     FGet(C)

FGet: `INTEGER(KIND=1)' function.

C: `CHARACTER'; scalar; INTENT(OUT).

Intrinsic groups: `badu77'.

Description:

   Reads a single character into C in stream mode from unit 5
(by-passing normal formatted input) using `getc(3)'.  Returns 0 on
success, -1 on end-of-file, and the error code from `ferror(3)'
otherwise.

   Stream I/O should not be mixed with normal record-oriented
(formatted or unformatted) I/O on the same unit; the results are
unpredictable.

   For information on other intrinsics with the same name: *Note FGet
Intrinsic (subroutine)::.


File: g77.info,  Node: FGetC Intrinsic (function),  Next: FloatI Intrinsic,  Prev: FGet Intrinsic (function),  Up: Other Intrinsics

FGetC Intrinsic (function)
..........................

     FGetC(UNIT, C)

FGetC: `INTEGER(KIND=1)' function.

UNIT: `INTEGER'; scalar; INTENT(IN).

C: `CHARACTER'; scalar; INTENT(OUT).

Intrinsic groups: `badu77'.

Description:

   Reads a single character into C in stream mode from unit UNIT
(by-passing normal formatted output) using `getc(3)'.  Returns 0 on
success, -1 on end-of-file, and the error code from `ferror(3)'
otherwise.

   Stream I/O should not be mixed with normal record-oriented
(formatted or unformatted) I/O on the same unit; the results are
unpredictable.

   For information on other intrinsics with the same name: *Note FGetC
Intrinsic (subroutine)::.


File: g77.info,  Node: FloatI Intrinsic,  Next: FloatJ Intrinsic,  Prev: FGetC Intrinsic (function),  Up: Other Intrinsics

FloatI Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL FloatI' to use this name for an
external procedure.


File: g77.info,  Node: FloatJ Intrinsic,  Next: FPut Intrinsic (function),  Prev: FloatI Intrinsic,  Up: Other Intrinsics

FloatJ Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL FloatJ' to use this name for an
external procedure.


File: g77.info,  Node: FPut Intrinsic (function),  Next: FPutC Intrinsic (function),  Prev: FloatJ Intrinsic,  Up: Other Intrinsics

FPut Intrinsic (function)
.........................

     FPut(C)

FPut: `INTEGER(KIND=1)' function.

C: `CHARACTER'; scalar; INTENT(IN).

Intrinsic groups: `badu77'.

Description:

   Writes the single character C in stream mode to unit 6 (by-passing
normal formatted output) using `getc(3)'.  Returns 0 on success, the
error code from `ferror(3)' otherwise.

   Stream I/O should not be mixed with normal record-oriented
(formatted or unformatted) I/O on the same unit; the results are
unpredictable.

   For information on other intrinsics with the same name: *Note FPut
Intrinsic (subroutine)::.


File: g77.info,  Node: FPutC Intrinsic (function),  Next: IDate Intrinsic (VXT),  Prev: FPut Intrinsic (function),  Up: Other Intrinsics

FPutC Intrinsic (function)
..........................

     FPutC(UNIT, C)

FPutC: `INTEGER(KIND=1)' function.

UNIT: `INTEGER'; scalar; INTENT(IN).

C: `CHARACTER'; scalar; INTENT(IN).

Intrinsic groups: `badu77'.

Description:

   Writes the single character C in stream mode to unit UNIT
(by-passing normal formatted output) using `putc(3)'.  Returns 0 on
success, the error code from `ferror(3)' otherwise.

   Stream I/O should not be mixed with normal record-oriented
(formatted or unformatted) I/O on the same unit; the results are
unpredictable.

   For information on other intrinsics with the same name: *Note FPutC
Intrinsic (subroutine)::.


File: g77.info,  Node: IDate Intrinsic (VXT),  Next: IIAbs Intrinsic,  Prev: FPutC Intrinsic (function),  Up: Other Intrinsics

IDate Intrinsic (VXT)
.....................

     CALL IDate(M, D, Y)

M: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

D: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

Y: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

Intrinsic groups: `vxt'.

Description:

   Returns the numerical values of the current local time.  The month
(in the range 1-12) is returned in M, the day (in the range 1-7) in D,
and the year in Y (in the range 0-99).

   This intrinsic is not recommended, due to the year 2000 approaching.

   For information on other intrinsics with the same name: *Note IDate
Intrinsic (UNIX)::.


File: g77.info,  Node: IIAbs Intrinsic,  Next: IIAnd Intrinsic,  Prev: IDate Intrinsic (VXT),  Up: Other Intrinsics

IIAbs Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIAbs' to use this name for an
external procedure.


File: g77.info,  Node: IIAnd Intrinsic,  Next: IIBClr Intrinsic,  Prev: IIAbs Intrinsic,  Up: Other Intrinsics

IIAnd Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIAnd' to use this name for an
external procedure.


File: g77.info,  Node: IIBClr Intrinsic,  Next: IIBits Intrinsic,  Prev: IIAnd Intrinsic,  Up: Other Intrinsics

IIBClr Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIBClr' to use this name for an
external procedure.


File: g77.info,  Node: IIBits Intrinsic,  Next: IIBSet Intrinsic,  Prev: IIBClr Intrinsic,  Up: Other Intrinsics

IIBits Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIBits' to use this name for an
external procedure.


File: g77.info,  Node: IIBSet Intrinsic,  Next: IIDiM Intrinsic,  Prev: IIBits Intrinsic,  Up: Other Intrinsics

IIBSet Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIBSet' to use this name for an
external procedure.


File: g77.info,  Node: IIDiM Intrinsic,  Next: IIDInt Intrinsic,  Prev: IIBSet Intrinsic,  Up: Other Intrinsics

IIDiM Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIDiM' to use this name for an
external procedure.


File: g77.info,  Node: IIDInt Intrinsic,  Next: IIDNnt Intrinsic,  Prev: IIDiM Intrinsic,  Up: Other Intrinsics

IIDInt Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIDInt' to use this name for an
external procedure.


File: g77.info,  Node: IIDNnt Intrinsic,  Next: IIEOr Intrinsic,  Prev: IIDInt Intrinsic,  Up: Other Intrinsics

IIDNnt Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIDNnt' to use this name for an
external procedure.


File: g77.info,  Node: IIEOr Intrinsic,  Next: IIFix Intrinsic,  Prev: IIDNnt Intrinsic,  Up: Other Intrinsics

IIEOr Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIEOr' to use this name for an
external procedure.


File: g77.info,  Node: IIFix Intrinsic,  Next: IInt Intrinsic,  Prev: IIEOr Intrinsic,  Up: Other Intrinsics

IIFix Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIFix' to use this name for an
external procedure.


File: g77.info,  Node: IInt Intrinsic,  Next: IIOr Intrinsic,  Prev: IIFix Intrinsic,  Up: Other Intrinsics

IInt Intrinsic
..............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IInt' to use this name for an
external procedure.


File: g77.info,  Node: IIOr Intrinsic,  Next: IIQint Intrinsic,  Prev: IInt Intrinsic,  Up: Other Intrinsics

IIOr Intrinsic
..............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIOr' to use this name for an
external procedure.


File: g77.info,  Node: IIQint Intrinsic,  Next: IIQNnt Intrinsic,  Prev: IIOr Intrinsic,  Up: Other Intrinsics

IIQint Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIQint' to use this name for an
external procedure.


File: g77.info,  Node: IIQNnt Intrinsic,  Next: IIShftC Intrinsic,  Prev: IIQint Intrinsic,  Up: Other Intrinsics

IIQNnt Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIQNnt' to use this name for an
external procedure.


File: g77.info,  Node: IIShftC Intrinsic,  Next: IISign Intrinsic,  Prev: IIQNnt Intrinsic,  Up: Other Intrinsics

IIShftC Intrinsic
.................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IIShftC' to use this name for
an external procedure.


File: g77.info,  Node: IISign Intrinsic,  Next: IMax0 Intrinsic,  Prev: IIShftC Intrinsic,  Up: Other Intrinsics

IISign Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IISign' to use this name for an
external procedure.


File: g77.info,  Node: IMax0 Intrinsic,  Next: IMax1 Intrinsic,  Prev: IISign Intrinsic,  Up: Other Intrinsics

IMax0 Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IMax0' to use this name for an
external procedure.


File: g77.info,  Node: IMax1 Intrinsic,  Next: IMin0 Intrinsic,  Prev: IMax0 Intrinsic,  Up: Other Intrinsics

IMax1 Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IMax1' to use this name for an
external procedure.


File: g77.info,  Node: IMin0 Intrinsic,  Next: IMin1 Intrinsic,  Prev: IMax1 Intrinsic,  Up: Other Intrinsics

IMin0 Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IMin0' to use this name for an
external procedure.


File: g77.info,  Node: IMin1 Intrinsic,  Next: IMod Intrinsic,  Prev: IMin0 Intrinsic,  Up: Other Intrinsics

IMin1 Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IMin1' to use this name for an
external procedure.


File: g77.info,  Node: IMod Intrinsic,  Next: INInt Intrinsic,  Prev: IMin1 Intrinsic,  Up: Other Intrinsics

IMod Intrinsic
..............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IMod' to use this name for an
external procedure.


File: g77.info,  Node: INInt Intrinsic,  Next: INot Intrinsic,  Prev: IMod Intrinsic,  Up: Other Intrinsics

INInt Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL INInt' to use this name for an
external procedure.


File: g77.info,  Node: INot Intrinsic,  Next: IZExt Intrinsic,  Prev: INInt Intrinsic,  Up: Other Intrinsics

INot Intrinsic
..............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL INot' to use this name for an
external procedure.


File: g77.info,  Node: IZExt Intrinsic,  Next: JIAbs Intrinsic,  Prev: INot Intrinsic,  Up: Other Intrinsics

IZExt Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL IZExt' to use this name for an
external procedure.


File: g77.info,  Node: JIAbs Intrinsic,  Next: JIAnd Intrinsic,  Prev: IZExt Intrinsic,  Up: Other Intrinsics

JIAbs Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL JIAbs' to use this name for an
external procedure.


File: g77.info,  Node: JIAnd Intrinsic,  Next: JIBClr Intrinsic,  Prev: JIAbs Intrinsic,  Up: Other Intrinsics

JIAnd Intrinsic
...............

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL JIAnd' to use this name for an
external procedure.


File: g77.info,  Node: JIBClr Intrinsic,  Next: JIBits Intrinsic,  Prev: JIAnd Intrinsic,  Up: Other Intrinsics

JIBClr Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL JIBClr' to use this name for an
external procedure.


File: g77.info,  Node: JIBits Intrinsic,  Next: JIBSet Intrinsic,  Prev: JIBClr Intrinsic,  Up: Other Intrinsics

JIBits Intrinsic
................

   This intrinsic is not yet implemented.  The name is, however,
reserved as an intrinsic.  Use `EXTERNAL JIBits' to use this name for an
external procedure.

